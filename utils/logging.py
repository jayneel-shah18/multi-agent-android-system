#!/usr/bin/env python3
"""
Logging Utilities - Centralized Logging Configuration
====================================================

This module provides comprehensive logging utilities for the multi-agent system,
including structured JSON logging for pipeline tracking, agent action logging,
and performance metrics collection.

Key Features:
- Centralized logger configuration with consistent formatting
- Structured JSON logging for complex data analysis
- Agent-specific action logging with context
- QA run logging with timestamped output files
- Performance metrics and execution tracking
- Automatic log directory management

Author: Multi-Agent System Team
Version: 1.0
"""

import logging
import os
import json
from datetime import datetime
from typing import Optional, Dict, Any, List, Union
from pathlib import Path

def setup_logger(name: str, log_file: Optional[str] = None, level: int = logging.INFO) -> logging.Logger:
    """
    Set up a comprehensive logger with consistent formatting and file handling.
    
    Creates a logger instance with both console and file output, automatic
    directory creation, and standardized formatting across the system.
    
    Args:
        name: Logger name/identifier (typically agent name)
        log_file: Optional custom log file path. If None, auto-generates
                 timestamped filename in logs/ directory
        level: Logging level (DEBUG, INFO, WARNING, ERROR)
    
    Returns:
        logging.Logger: Configured logger instance ready for use
        
    Example:
        >>> logger = setup_logger("PlannerAgent", level=logging.DEBUG)
        >>> logger.info("Agent initialized successfully")
    """
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    # Avoid adding multiple handlers if logger already exists
    if logger.handlers:
        return logger
    
    # Create standardized formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Console handler for real-time output
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_handler.setFormatter(formatter)
    
    # Handle encoding issues on Windows for Unicode characters
    if hasattr(console_handler.stream, 'reconfigure'):
        try:
            console_handler.stream.reconfigure(encoding='utf-8')
        except Exception:
            # Fallback: continue without encoding changes
            pass
    
    logger.addHandler(console_handler)
    
    # File handler for persistent logging
    if log_file is None:
        # Create timestamped log file name
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_file = f"logs/{name}_{timestamp}.log"
    
    # Ensure logs directory exists
    log_dir = os.path.dirname(log_file)
    if log_dir and not os.path.exists(log_dir):
        os.makedirs(log_dir, exist_ok=True)
    
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(level)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    
    return logger


def log_plan(logger: logging.Logger, goal: str, plan: List[str], agent_name: str = "PlannerAgent") -> None:
    """
    Log a generated plan in a structured, readable format.
    
    Creates a formatted log entry with clear boundaries and numbered steps
    for easy reading and debugging.
    
    Args:
        logger: Logger instance to write to
        goal: The original goal/task description
        plan: List of steps in the generated plan
        agent_name: Name of the agent that generated the plan
    """
    logger.info(f"=== PLAN GENERATED BY {agent_name} ===")
    logger.info(f"Goal: {goal}")
    logger.info(f"Number of steps: {len(plan)}")
    logger.info("Plan steps:")
    for i, step in enumerate(plan, 1):
        logger.info(f"  {i}. {step}")
    logger.info("=== END PLAN ===")


def log_agent_action(logger: logging.Logger, agent_name: str, action: str, details: Optional[str] = None) -> None:
    """
    Log an agent action with standardized formatting and optional details.
    
    Provides consistent action logging across all agents in the system
    with optional additional context information.
    
    Args:
        logger: Logger instance
        agent_name: Name of the agent
        action: Action being performed
        details: Optional additional details
    """
    msg = f"[{agent_name}] {action}"
    if details:
        msg += f" - {details}"
    logger.info(msg)


class StructuredLogger:
    """
    Structured logger for comprehensive pipeline tracking and JSON export.
    Records planner steps, executor actions, verifier results, and replanning events.
    """
    
    def __init__(self, goal: str, logger_name: str = "StructuredLogger"):
        """
        Initialize structured logger for a specific goal.
        
        Args:
            goal: The automation goal being tracked
            logger_name: Name for the logger instance
        """
        self.goal = goal
        self.logger_name = logger_name
        self.logger = setup_logger(logger_name, level=logging.INFO)
        
        # Initialize structured log data
        self.log_data = {
            "goal": goal,
            "start_time": datetime.now().isoformat(),
            "end_time": None,
            "duration_seconds": None,
            "steps": [],
            "replans": [],
            "final_status": "unknown",
            "statistics": {
                "total_steps": 0,
                "successful_steps": 0,
                "failed_steps": 0,
                "verification_passes": 0,
                "verification_failures": 0,
                "bugs_detected": 0,
                "replanning_events": 0
            },
            "metadata": {
                "logger_version": "1.0",
                "created_by": "AndroidAutomationPipeline"
            }
        }
        
        self.current_step_index = 0
        self.start_time = datetime.now()
        
        self.logger.info(f"[{self.logger_name}] Structured logging initialized for goal: '{goal}'")
    
    def log_step_start(self, step: str, step_type: str = "execution") -> int:
        """
        Log the start of a new step.
        
        Args:
            step: Step description
            step_type: Type of step (execution, replan, etc.)
            
        Returns:
            int: Step index for tracking
        """
        self.current_step_index += 1
        
        step_data = {
            "step_index": self.current_step_index,
            "step": step,
            "step_type": step_type,
            "start_time": datetime.now().isoformat(),
            "end_time": None,
            "duration_seconds": None,
            "planner_info": None,
            "executor_info": None,
            "verifier_info": None,
            "status": "in_progress"
        }
        
        self.log_data["steps"].append(step_data)
        self.log_data["statistics"]["total_steps"] += 1
        
        self.logger.info(f"[{self.logger_name}] Step {self.current_step_index} started: '{step}'")
        return self.current_step_index
    
    def log_planner_result(self, step_index: int, plan: List[str], replanning: bool = False, context: str = None):
        """
        Log planner generation result.
        
        Args:
            step_index: Index of the step this plan applies to
            plan: Generated plan steps
            replanning: Whether this is a replanning event
            context: Additional context for replanning
        """
        planner_info = {
            "timestamp": datetime.now().isoformat(),
            "plan_generated": plan,
            "plan_length": len(plan),
            "is_replanning": replanning,
            "context": context
        }
        
        # Update step data
        if step_index <= len(self.log_data["steps"]):
            self.log_data["steps"][step_index - 1]["planner_info"] = planner_info
        
        # Track replanning events
        if replanning:
            replan_data = {
                "step_index": step_index,
                "timestamp": datetime.now().isoformat(),
                "trigger": context or "step_failure",
                "new_plan": plan,
                "plan_length": len(plan)
            }
            self.log_data["replans"].append(replan_data)
            self.log_data["statistics"]["replanning_events"] += 1
            
            self.logger.info(f"[{self.logger_name}] Replanning logged for step {step_index}")
        
        self.logger.info(f"[{self.logger_name}] Planner result logged for step {step_index}")
    
    def log_executor_action(self, step_index: int, action: Dict[str, Any], element_info: Dict = None, 
                          success: bool = True, error: str = None):
        """
        Log executor action details.
        
        Args:
            step_index: Index of the step being executed
            action: Action dictionary from executor
            element_info: Information about UI element targeted
            success: Whether action execution succeeded
            error: Error message if action failed
        """
        executor_info = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "element_info": element_info,
            "success": success,
            "error": error
        }
        
        # Update step data
        if step_index <= len(self.log_data["steps"]):
            self.log_data["steps"][step_index - 1]["executor_info"] = executor_info
        
        if success:
            self.log_data["statistics"]["successful_steps"] += 1
        else:
            self.log_data["statistics"]["failed_steps"] += 1
        
        status = "success" if success else "failed"
        self.logger.info(f"[{self.logger_name}] Executor action logged for step {step_index}: {status}")
    
    def log_verifier_result(self, step_index: int, verification_status: str, confidence: float = None,
                           reason: str = None, details: Dict = None):
        """
        Log verifier result and analysis.
        
        Args:
            step_index: Index of the step being verified
            verification_status: "pass", "fail", or "bug_detected"
            confidence: Confidence score from verifier
            reason: Verification reasoning
            details: Additional verification details
        """
        verifier_info = {
            "timestamp": datetime.now().isoformat(),
            "verification_status": verification_status,
            "confidence": confidence,
            "reason": reason,
            "details": details
        }
        
        # Update step data
        if step_index <= len(self.log_data["steps"]):
            self.log_data["steps"][step_index - 1]["verifier_info"] = verifier_info
        
        # Update statistics
        if verification_status == "pass":
            self.log_data["statistics"]["verification_passes"] += 1
        elif verification_status == "fail":
            self.log_data["statistics"]["verification_failures"] += 1
        elif verification_status == "bug_detected":
            self.log_data["statistics"]["bugs_detected"] += 1
        
        self.logger.info(f"[{self.logger_name}] Verifier result logged for step {step_index}: {verification_status}")
    
    def log_step_completion(self, step_index: int, final_status: str = "completed"):
        """
        Mark a step as completed and record timing.
        
        Args:
            step_index: Index of the completed step
            final_status: Final status of the step
        """
        if step_index <= len(self.log_data["steps"]):
            step_data = self.log_data["steps"][step_index - 1]
            step_data["end_time"] = datetime.now().isoformat()
            step_data["status"] = final_status
            
            # Calculate duration
            if step_data["start_time"]:
                start_time = datetime.fromisoformat(step_data["start_time"])
                end_time = datetime.fromisoformat(step_data["end_time"])
                duration = (end_time - start_time).total_seconds()
                step_data["duration_seconds"] = round(duration, 3)
        
        self.logger.info(f"[{self.logger_name}] Step {step_index} completed with status: {final_status}")
    
    def finalize_log(self, final_status: str = "completed", additional_stats: Dict = None):
        """
        Finalize the structured log and prepare for export.
        
        Args:
            final_status: Final status of the entire goal execution
            additional_stats: Additional statistics to include
        """
        self.log_data["end_time"] = datetime.now().isoformat()
        self.log_data["final_status"] = final_status
        
        # Calculate total duration
        end_time = datetime.now()
        duration = (end_time - self.start_time).total_seconds()
        self.log_data["duration_seconds"] = round(duration, 3)
        
        # Merge additional statistics
        if additional_stats:
            self.log_data["statistics"].update(additional_stats)
        
        self.logger.info(f"[{self.logger_name}] Log finalized with status: {final_status}")
    
    def _make_json_serializable(self, obj):
        """
        Convert datetime objects and other non-JSON-serializable objects to strings.
        
        Args:
            obj: Object to make JSON serializable
            
        Returns:
            JSON serializable object
        """
        if isinstance(obj, dict):
            return {key: self._make_json_serializable(value) for key, value in obj.items()}
        elif isinstance(obj, list):
            return [self._make_json_serializable(item) for item in obj]
        elif isinstance(obj, datetime):
            return obj.isoformat()
        elif hasattr(obj, '__dict__'):
            # For custom objects, convert to dict
            return self._make_json_serializable(obj.__dict__)
        else:
            # For basic types (str, int, float, bool, None)
            return obj

    def save_json_log(self, custom_filename: str = None) -> str:
        """
        Save the structured log as a JSON file.
        
        Args:
            custom_filename: Custom filename, otherwise uses timestamp
            
        Returns:
            str: Path to saved log file
        """
        # Ensure logs directory exists
        logs_dir = Path("logs")
        logs_dir.mkdir(exist_ok=True)
        
        # Generate filename
        if custom_filename:
            filename = custom_filename
        else:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            # Clean goal name for filename
            clean_goal = "".join(c for c in self.goal if c.isalnum() or c in (' ', '-', '_')).rstrip()
            clean_goal = clean_goal.replace(' ', '_')[:50]  # Limit length
            filename = f"qa_run_{timestamp}_{clean_goal}.json"
        
        filepath = logs_dir / filename
        
        try:
            # Make data JSON serializable before saving
            serializable_data = self._make_json_serializable(self.log_data)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(serializable_data, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"[{self.logger_name}] Structured log saved to: {filepath}")
            return str(filepath)
            
        except Exception as e:
            self.logger.error(f"[{self.logger_name}] Failed to save log: {e}")
            raise
    
    def get_log_data(self) -> Dict[str, Any]:
        """
        Get the current log data structure.
        
        Returns:
            dict: Complete log data
        """
        return self.log_data.copy()
    
    def get_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the execution.
        
        Returns:
            dict: Execution summary
        """
        stats = self.log_data["statistics"]
        total_steps = stats["total_steps"]
        
        summary = {
            "goal": self.goal,
            "total_steps": total_steps,
            "success_rate": (stats["successful_steps"] / max(total_steps, 1)) * 100,
            "verification_pass_rate": (stats["verification_passes"] / max(total_steps, 1)) * 100,
            "replanning_events": stats["replanning_events"],
            "bugs_detected": stats["bugs_detected"],
            "final_status": self.log_data["final_status"],
            "duration_seconds": self.log_data["duration_seconds"]
        }
        
        return summary


def create_qa_log(goal: str) -> StructuredLogger:
    """
    Create a new structured logger for QA automation tracking.
    
    Args:
        goal: The automation goal to track
        
    Returns:
        StructuredLogger: Configured logger instance
    """
    return StructuredLogger(goal, logger_name="QALogger")
